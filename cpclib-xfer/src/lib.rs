use fs_err as fs;

use cpclib_common::camino::Utf8Path;
use curl::easy::{Easy, Form};
use custom_error::custom_error;
use path_absolutize::*;
use {cpclib_disc as disc, cpclib_sna as sna};

use crate::disc::amsdos::AmsdosFileType;
use crate::sna::{Snapshot, SnapshotVersion};

custom_error! {#[allow(missing_docs)] pub XferError
    ConnectionError2{source: Box<dyn custom_error::Error>} = "There is a connection error with the Cpc Wifi.",

    CdError{from: String, to: String} = @ {
        format!(
            "Unable to move in {}. Current working directory is {}.",
            from, to)
    },
    InternalError{reason: String} = @ {
        format!("Internal error: {}", reason)
    }
}

#[derive(Debug)]
/// File in a list of files generated by the m4
pub struct M4File {
    /// File name
    fname: String,
    /// TODO search what it is
    #[allow(dead_code)]
    unknown: String,
    /// File size
    #[allow(dead_code)]
    size: String
}

impl M4File {
    /// Return the filname
    pub fn fname(&self) -> &str {
        &self.fname
    }
}

impl From<&str> for M4File {
    fn from(line: &str) -> Self {
        let mut splitted = line.split(',');
        Self {
            fname: splitted.next().unwrap().into(),
            unknown: splitted.next().unwrap().into(),
            size: splitted.next().unwrap().into()
        }
    }
}

/// List of files in the M4
#[derive(Debug)]
pub struct M4FilesList {
    /// Directory of the list
    cwd: String,
    /// List of files
    files: Vec<M4File>
}

impl From<&str> for M4FilesList {
    // TODO Better test for catart

    fn from(buffer: &str) -> Self {
        let mut lines = buffer.lines();
        let mut path = lines.next().unwrap();
        if path == "//" {
            path = "/";
        }

        let mut lines = lines.map(String::from).collect::<Vec<String>>();
        let mut idx = 0;
        while idx < lines.len() {
            // check if current line is ok
            if lines[idx].match_indices(';').count() >= 2 && lines[lines.len() - 1] == "K" {
                idx += 1; // we can assume it is a standard file even if it may not be one
            }
            else if lines[idx].ends_with(",0,0") {
                // we can assume it is a directory
                idx += 1;
            }
            else {
                // we can consider it is a mistake because of cat art
                let new_string = format!("{}\n{}", lines[idx], lines[idx + 1]);
                lines[idx] = new_string;
            }
        }
        let files = lines
            .iter()
            .map(|s| s.as_str().into())
            .collect::<Vec<M4File>>();
        Self {
            cwd: path.into(),
            files
        }
    }
}

#[allow(missing_docs)]
impl M4FilesList {
    pub fn cwd(&self) -> &String {
        &self.cwd
    }

    pub fn nb_files(&self) -> usize {
        self.files.len()
    }

    // TODO do not give acces to the vector
    pub fn files(&self) -> &Vec<M4File> {
        &self.files
    }
}

/// Bridget the the CPC Wifi card
#[derive(Debug)]
pub struct CpcXfer {
    /// CPC Wifi hostname
    hostname: String
}

#[allow(missing_docs)]
impl CpcXfer {
    /// Create the CpcXfer given an address
    pub fn new<S: AsRef<str>>(hostname: S) -> Self {
        Self {
            hostname: String::from(hostname.as_ref())
        }
    }

    pub fn hostname(&self) -> &str {
        &self.hostname
    }

    /// Return the appropriate uri
    fn uri(&self, path: &str) -> String {
        format!("http://{}/{}", self.hostname, path)
    }

    /// Make a simple query
    fn simple_query(
        &self,
        query: &[(&str, &str)]
    ) -> Result<
        cpclib_common::network::http::Response<cpclib_common::network::ureq::Body>,
        Box<cpclib_common::network::ureq::Error>
    > {
        Ok(cpclib_common::network::ureq::get(&self.uri("config.cgi"))
            .query_pairs(query.iter().cloned())
            .header("User-Agent", "cpcxfer")
            .call()?)
    }

    /// Reset the M4
    pub fn reset_m4(&self) -> Result<(), Box<XferError>> {
        self.simple_query(&[("mres", "")])
            .map_err(|e| Box::new(XferError::ConnectionError2 { source: e }))?;
        Ok(())
    }

    /// Reset the Cpc
    pub fn reset_cpc(&self) -> Result<(), Box<XferError>> {
        self.simple_query(&[("cres", "")])
            .map_err(|e| Box::new(XferError::ConnectionError2 { source: e }))?;
        Ok(())
    }

    /// Run the file from the current selected path
    /// TODO debug this
    pub fn run_rom_current_path(&self, fname: &str) -> Result<(), Box<XferError>> {
        self.simple_query(&[("run", fname)])
            .map_err(|e| Box::new(XferError::ConnectionError2 { source: e }))?;
        Ok(())
    }

    /// Run the file whose complete path is provided
    pub fn run(&self, path: &str) -> Result<(), Box<XferError>> {
        let absolute = self.absolute_path(path)?;
        self.simple_query(&[("run2", &absolute)])
            .map_err(|e| Box::new(XferError::ConnectionError2 { source: e }))?;
        Ok(())
    }

    /// Remove the file whose complete path is provided
    pub fn rm<S: AsRef<str>>(&self, path: S) -> Result<(), Box<XferError>> {
        self.simple_query(&[("rm", path.as_ref())])
            .map_err(|e| Box::new(XferError::ConnectionError2 { source: e }))?;
        Ok(())
    }

    /// upload a file on the M4
    pub fn upload<P>(
        &self,
        path: P,
        m4_path: &str,
        header: Option<(AmsdosFileType, u16, u16)>
    ) -> Result<(), Box<XferError>>
    where
        P: AsRef<Utf8Path>
    {
        self.upload_impl(path.as_ref(), m4_path, header)
    }

    #[allow(clippy::similar_names)]
    pub fn upload_impl(
        &self,
        path: &Utf8Path,
        m4_path: &str,
        header: Option<(AmsdosFileType, u16, u16)>
    ) -> Result<(), Box<XferError>> {
        let local_fname = path.as_str();

        if m4_path.len() > 255 {
            panic!("{m4_path} path is too long (should be limited to 255 chars)");
        }
        let _file_contents = fs::read(local_fname).expect("Unable to read PC file");

        let local_fname = match header {
            Some(_header) => {
                unimplemented!();
                // Need to build header and compute checksum
                // Need to inject header
            },
            None => {
                // Header is already included within the file
                // TODO check that the header is correct
                local_fname
            }
        };

        // TODO manage more cases in order to allow to provide a destination folder or a destination filename or a different name
        let destination = Utf8Path::new(m4_path).join(
            Utf8Path::new(local_fname)
                .file_name()
                .expect("Unable to retreive the filename of the file to upload")
        );
        let destination = destination.to_string();

        let mut form = Form::new();
        form.part("upfile")
            .file(local_fname)
            .filename(&destination)
            .add()
            .unwrap();
        let mut easy = Easy::new();
        easy.url(&self.uri("files.shtml")).map_err(|e| {
            Box::new(XferError::ConnectionError2 {
                source: Box::new(e)
            })
        })?;
        easy.httppost(form).map_err(|e| {
            Box::new(XferError::ConnectionError2 {
                source: Box::new(e)
            })
        })?;
        easy.perform().map_err(|e| {
            Box::new(XferError::ConnectionError2 {
                source: Box::new(e)
            })
        })?;

        Ok(())
    }

    /// Directly sends the SNA to the M4. SNA is first saved as a V2 version as M4 is unable to read other ones
    pub fn upload_and_run_sna(&self, sna: &Snapshot) -> Result<(), Box<XferError>> {
        use camino_tempfile::Builder;
        let file = Builder::new()
            .prefix("xfer")
            .suffix(".sna")
            .rand_bytes(4)
            .tempfile()
            .map_err(|e| {
                XferError::InternalError {
                    reason: e.to_string()
                }
            })?;
        let temp_path = file.into_temp_path();

        sna.save(&temp_path, SnapshotVersion::V2).map_err(|e| {
            XferError::InternalError {
                reason: format!("Unable to save the snapshot. {e}")
            }
        })?;
        self.upload_and_run(&temp_path, None)?;

        // sleep a bit to be sure the file is not deleted BEFORE sending it to CPC
        std::thread::sleep(std::time::Duration::from_secs(5));
        temp_path.close().map_err(|e| {
            Box::new(XferError::InternalError {
                reason: e.to_string()
            })
        })
    }

    pub fn upload_and_run<P: AsRef<Utf8Path>>(
        &self,
        path: P,
        header: Option<(AmsdosFileType, u16, u16)>
    ) -> Result<(), Box<XferError>> {
        self.upload_and_run_impl(path.as_ref(), header)
    }

    fn upload_and_run_impl(
        &self,
        path: &Utf8Path,
        header: Option<(AmsdosFileType, u16, u16)>
    ) -> Result<(), Box<XferError>> {
        // We are sure it is not a snapshot there
        self.upload_impl(path, "/tmp", header)?;
        self.run(&format!("/tmp/{}", path.file_name().unwrap()))?;
        Ok(())
    }

    pub fn current_folder_content(&self) -> Result<M4FilesList, Box<XferError>> {
        self.download_dir()
    }

    pub fn current_working_directory(&self) -> Result<String, Box<XferError>> {
        let data = self.download_dir()?;
        Ok(data.cwd().clone())
    }

    fn download_dir(&self) -> Result<M4FilesList, Box<XferError>> {
        let mut dst = Vec::new();
        {
            {
                let mut easy = Easy::new();
                easy.url(&self.uri("sd/m4/dir.txt")).map_err(|e| {
                    Box::new(XferError::ConnectionError2 {
                        source: Box::new(e)
                    })
                })?;
                let mut easy = easy.transfer();
                easy.write_function(|data| {
                    dst.extend_from_slice(data);
                    Ok(data.len())
                })
                .map_err(|e| {
                    Box::new(XferError::ConnectionError2 {
                        source: Box::new(e)
                    })
                })?;
                easy.perform().map_err(|e| {
                    Box::new(XferError::ConnectionError2 {
                        source: Box::new(e)
                    })
                })?;
            }
        }

        let content =
            std::str::from_utf8(&dst).expect("Unable to create an UTF8 string for M4 content");

        Ok(M4FilesList::from(content)) // TODO use try-from
    }

    /// Change the current directory
    pub fn cd(&self, directory: &str) -> Result<(), Box<XferError>> {
        // Get the absolute directory
        let mut directory = if let Some('/') = directory.chars().next() {
            directory.to_owned()
        }
        else {
            self.absolute_path(directory)?
        };

        self.ls_request(&directory)?;

        // Ensure theire is a / at the end
        if !directory.ends_with('/') {
            directory.push('/');
        }
        let cwd = self.current_working_directory()?;

        if cwd == directory {
            Ok(())
        }
        else {
            Err(Box::new(XferError::CdError {
                from: directory,
                to: cwd
            }))
        }
    }

    fn absolute_path(&self, relative: &str) -> Result<String, Box<XferError>> {
        match relative.chars().next() {
            None => {
                Err(Box::new(XferError::InternalError {
                    reason: "No path provided".into()
                }))
            },
            Some('/') => Ok(relative.to_owned()),
            _ => {
                let cwd = self.current_working_directory()?;
                let absolute = Utf8Path::new(&cwd).join(relative);

                let absolute = absolute.as_std_path().absolutize().unwrap();
                let path: String = absolute.to_str().unwrap().into();
                if cfg!(target_os = "windows") {
                    return Ok(path.replace("C:\\", "/"));
                }

                Ok(path)
            }
        }
    }

    pub fn ls_request(&self, folder: &str) -> Result<(), Box<XferError>> {
        let mut easy = Easy::new();
        let folder = easy.url_encode(folder.as_bytes());
        easy.get(true).map_err(|e| {
            Box::new(XferError::ConnectionError2 {
                source: Box::new(e)
            })
        })?;
        let url = format!("{}?ls={}", self.uri("config.cgi"), folder);
        easy.url(&url).map_err(|e| {
            Box::new(XferError::ConnectionError2 {
                source: Box::new(e)
            })
        })?;
        easy.perform().map_err(|e| {
            Box::new(XferError::ConnectionError2 {
                source: Box::new(e)
            })
        })?;
        Ok(())
    }
}

/// Send and run the file on the CPC.
/// Snapshot V3 are downgraded to the V2 version
pub fn send_and_run_file<P: AsRef<Utf8Path>>(
    xfer: &CpcXfer,
    fname: P,
    run: bool
) -> Result<(), Box<XferError>> {
    let mut done = false;
    let fname = fname.as_ref();
    // Snapshot needs to be converted in V2 format and handled differently
    if let Some(extension) = fname.extension() {
        let extension = extension.to_ascii_lowercase();
        if extension == "sna" {
            let sna = sna::Snapshot::load(fname).expect("Error while loading snapshot");
            if sna.version_header() == 3 {
                eprintln!(
                    "Need to downgrade SNA version. TODO check if it is sill necessary (I think not)"
                );
                let sna_fname = fname.file_name().unwrap();
                sna.save(sna_fname, sna::SnapshotVersion::V2).unwrap();
                xfer.upload_and_run(sna_fname, None)
                    .expect("Unable to launch SNA");
                done = true;
            }
        }
    }
    if !done {
        if run {
            xfer.upload_and_run(fname, None)?;
            //   .expect("Unable to launch file");
        }
        else {
            xfer.upload(fname, "/", None)?;
            //    .expect("Unable to put the file");
        }
    };

    Ok(())
}
