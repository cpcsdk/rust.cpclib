use std::collections::{BTreeMap, HashSet};
use std::path::{Path, PathBuf};

use cpclib_common::itertools::Itertools;
use serde::de::Visitor;
use serde::{self, Deserialize, Deserializer};
use topologic::AcyclicDependencyGraph;

use crate::constraints::{deserialize_constraint, Constraint};
use crate::executor::execute;
use crate::task::Task;
use crate::{expand_glob, BndBuilderError};

#[derive(Debug, Deserialize, PartialEq, Eq, Hash)]
pub struct Rule {
    /// List of files generated by this rule
    #[serde(deserialize_with = "deserialize_path_list")]
    #[serde(alias = "tgt", alias = "target", alias = "build")]
    targets: Vec<PathBuf>,

    /// List of dependencies that need to be up to date
    #[serde(deserialize_with = "deserialize_path_list")]
    #[serde(alias = "dep", alias = "dependency", alias = "requires")]
    #[serde(default)]
    dependencies: Vec<PathBuf>,

    /// List of commands needed to execute the rule. Can be empty if we just want to manipulate virtual targets
    #[serde(deserialize_with = "deserialize_task_list")]
    #[serde(alias = "cmd", alias = "command", alias = "launch", alias = "run")]
    #[serde(default)]
    commands: Vec<Task>,

    /// Potential help for the user
    help: Option<String>,

    /// Explicit for extern commands
    phony: Option<bool>,

    /// Constraint to disable the rule
    #[serde(deserialize_with = "deserialize_constraint")]
    #[serde(default)]
    constraint: Option<Constraint>
}

fn deserialize_path_list<'de, D>(deserializer: D) -> Result<Vec<PathBuf>, D::Error>
where D: Deserializer<'de> {
    let s = String::deserialize(deserializer)?;
    let r = shlex::split(&s).or(Some(vec![])).unwrap();
    let r = r
        .into_iter()
        .map(|s| expand_glob(s.as_ref()))
        .flatten()
        .map(|s| if s.starts_with(r"./") || s.starts_with(r".\") {
            s[2..].to_owned()
        }
        else {
            s
        })
        .map(|s| PathBuf::from(s))
        .collect_vec();

    Ok(r)
}

fn deserialize_task_list<'de, D>(deserializer: D) -> Result<Vec<Task>, D::Error>
where D: Deserializer<'de> {
    struct SequenceOrList;

    impl<'de> Visitor<'de> for SequenceOrList {
        type Value = Vec<Task>;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("command or list of commands")
        }

        fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>
        where A: serde::de::EnumAccess<'de> {
            let t: Task =
                Deserialize::deserialize(serde::de::value::EnumAccessDeserializer::new(data))?;
            Ok(vec![t])
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where E: serde::de::Error {
            let t: Task = Deserialize::deserialize(serde::de::value::StrDeserializer::new(v))?;
            Ok(vec![t])
        }

        fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>
        where A: serde::de::SeqAccess<'de> {
            Deserialize::deserialize(serde::de::value::SeqAccessDeserializer::new(seq))
        }
    }

    deserializer.deserialize_any(SequenceOrList)
}

impl Rule {
    pub fn new<S: AsRef<str>, T: Into<Task> + Clone>(
        targets: &[S],
        dependencies: &[S],
        commands: &[T]
    ) -> Self {
        Self {
            targets: targets
                .into_iter()
                .map(|s| expand_glob(s.as_ref()))
                .flatten()
                .map(|s| PathBuf::from(s))
                .collect_vec(),
            dependencies: dependencies
                .into_iter()
                .map(|s| expand_glob(s.as_ref()))
                .flatten()
                .map(|s| PathBuf::from(s))
                .collect_vec(),
            commands: commands
                .into_iter()
                .map(|t| (t.clone()).into())
                .collect_vec(),
            help: None,
            phony: None,
            constraint: None
        }
    }

    pub fn commands(&self) -> &[Task] {
        &self.commands
    }

    /// Phony commands do not generate files and need to be launched each time (except in watch sessions)
    pub fn is_phony(&self) -> bool {
        if let Some(phony) = self.phony.as_ref() {
            return *phony;
        }

        if self.commands().is_empty() {
            true
        }
        else {
            self.commands().iter().all(|c| c.is_phony())
        }
    }

    pub fn is_up_to_date(&self) -> bool {
        // No need to try if one is missing
        if self.targets.iter().any(|p| !p.exists()) {
            return false;
        }

        let oldest_target = self
            .targets
            .iter()
            .filter(|p| p.exists())
            .map(|p| p.metadata().unwrap().modified().unwrap())
            .min();

        let newest_dependencies = self
            .dependencies
            .iter()
            .filter(|p| p.exists())
            .map(|p| p.metadata().unwrap().modified().unwrap())
            .max();

        oldest_target > newest_dependencies
    }

    pub fn help(&self) -> Option<&str> {
        self.help.as_ref().map(|s| s.as_str())
    }

    pub fn targets(&self) -> Vec<&Path> {
        self.targets.iter().map(|t| t.as_ref()).collect_vec()
    }

    pub fn dependencies(&self) -> Vec<&Path> {
        self.dependencies.iter().map(|t| t.as_ref()).collect_vec()
    }

    pub fn is_enabled(&self) -> bool {
        if let Some(constraint) = &self.constraint {
            constraint.corresponds()
        }
        else {
            true
        }
    }

}

#[derive(Deserialize)]
#[serde(transparent)]
pub struct Rules {
    rules: Vec<Rule>
}

impl Rules {
    pub fn new(rules: Vec<Rule>) -> Self {
        Rules { rules }
    }

    pub fn rules(&self) -> &[Rule] {
        &self.rules
    }

    /// Get the rule for this target (of course None is returned for leaf files)
    pub fn rule<P: AsRef<Path>>(&self, tgt: P) -> Option<&Rule> {
        let tgt = tgt.as_ref();

        // remove current dir path if any
        let tgt = if tgt.starts_with(r"./") {
            tgt.strip_prefix(r"./").unwrap()
        } else if dbg!(tgt.to_str().unwrap().starts_with(r".\")) {
            Path::new(&tgt.to_str().unwrap()[2..])
        }else {
            tgt
        };

        self.rules
            .iter()
            .find(|r| r.targets.iter().any(|tgt2| tgt2 == tgt))
    }

    pub fn default_target(&self) -> Option<&Path> {
        self.rules.get(0).map(|r| r.targets[0].as_ref())
    }

    // TODO implement a version with less copy
    pub fn to_deps(&self) -> Result<Graph, BndBuilderError> {
        let mut g = AcyclicDependencyGraph::<&Path>::new();
        let mut node2tracked_idx: BTreeMap<&Path, usize> = BTreeMap::new();

        for (idx, rule) in self.rules.iter().enumerate() {
            if !rule.is_enabled() {
                continue;
            }

            for p in rule.targets.iter() {
                let p: &Path = p.as_ref();
                // link the rule to the target
                if node2tracked_idx.contains_key(p) {
                    let other_rule_idx = node2tracked_idx.get(p).unwrap();
                    let other_rule = &self.rules[*other_rule_idx];
                    return Err(BndBuilderError::DependencyError(
                        format! {"{} has already a rule to build it:\n{:?}", p.display(), other_rule}
                    ));
                }
                else {
                    node2tracked_idx.insert(p, idx);
                }

                // link the target to the dependencies
                for p2 in rule.dependencies.iter() {
                    g.depend_on(p, p2).map_err(|_e| {
                        BndBuilderError::DependencyError(format!(
                            "{} and {}",
                            p.display(),
                            p2.display()
                        ))
                    })?;
                }
            }
        }

        Ok(Graph {
            node2tracked: node2tracked_idx,
            tracked: self,
            g
        })
    }
}

#[derive(Clone)]
pub struct Graph<'r> {
    node2tracked: BTreeMap<&'r Path, usize>,
    tracked: &'r Rules,
    g: AcyclicDependencyGraph<&'r Path>
}

#[derive(Default)]
struct ExecutionState {
    nb_deps: usize,
    task_count: usize
}

impl<'r> Graph<'r> {
    pub fn get_layered_dependencies(&self) -> Vec<HashSet<&Path>> {
        let mut res = self.g.get_forward_dependency_topological_layers();
        let orphans = self
            .tracked
            .rules
            .iter() // get the nodes that are not in the graph because they have no dependencies
            .filter(|rule| rule.dependencies.is_empty())
            .flat_map(|r| &r.targets)
            .map(|p| p.as_path())
            .collect::<HashSet<&Path>>();
        if !orphans.is_empty() {
            res.push(orphans);
        }
        res.reverse();
        res
    }

    pub fn get_layered_dependencies_for<P: AsRef<Path>>(&self, p: &'r P) -> Vec<HashSet<&Path>> {
        let p: &Path = p.as_ref();
        let mut layers = self.g.get_forward_dependency_topological_layers();
        let mut nodes = self.g.get_forward_dependencies(&p);
        nodes.insert(p);

        // For each layer, keep only the nodes belonging the the dependency
        for layer in layers.iter_mut() {
            *layer = layer.intersection(&nodes).cloned().collect();
        }

        // remove empty layers if any
        layers.into_iter().filter(|l| !l.is_empty()).collect_vec()
    }

    pub fn show_dependencies(&self, p: &PathBuf) {
        let layers = self.get_layered_dependencies_for(p);

        for layer in layers {
            println!("{:?}", layer)
        }
    }

    pub fn outdated<P: AsRef<Path>>(
        &self,
        p: P,
        skip_rules_without_commands: bool
    ) -> Result<bool, BndBuilderError> {
        let dependences = self.get_layered_dependencies_for(&p);
        let dependencies = dependences.into_iter().flatten().collect_vec();
        let res = dependencies.into_iter().rev().any(|p| {
            self.rule(p)
                .map(|r| {
                    if skip_rules_without_commands {
                        if r.is_phony() {
                            false
                        }
                        else {
                            !r.is_up_to_date()
                        }
                    }
                    else {
                        !r.is_up_to_date()
                    }
                })
                .unwrap_or(false) // ignore not existing rule. Should fail ?
        });
        Ok(res)
    }

    pub fn rule<P: AsRef<Path>>(&self, p: P) -> Option<&Rule> {
        let p = p.as_ref();
        self.node2tracked
            .get(p)
            .map(|idx| &self.tracked.rules[*idx])
    }

    pub fn execute<P: AsRef<Path>>(&self, p: P) -> Result<(), BndBuilderError> {
        let p = p.as_ref();
        println!("> Compute dependencies");

        let layers = self.get_layered_dependencies_for(&p);
        let mut state = ExecutionState {
            nb_deps: layers.iter().map(|l| l.len()).sum::<usize>(),
            task_count: 0
        };

        if state.nb_deps == 0 {
            if self.node2tracked.contains_key(p) {
                println!("> Execute task");
                state.nb_deps = 1;
                self.execute_rule(p, &mut state)?;
            }
            else {
                return Err(BndBuilderError::ExecuteError {
                    fname: p.display().to_string(),
                    msg: "no rule to build it".to_owned()
                });
            }
        }
        else {
            println!("> Execute tasks");
            for layer in layers.into_iter() {
                self.execute_layer(layer, &mut state)?;
            }
        }
        println!("> Done.");

        Ok(())
    }

    fn execute_layer(
        &self,
        layer: HashSet<&Path>,
        state: &mut ExecutionState
    ) -> Result<(), BndBuilderError> {
        layer
            .into_iter()
            .map(|p| self.execute_rule(&p, state))
            .collect::<Result<Vec<()>, BndBuilderError>>()?;
        Ok(())
    }

    fn execute_rule<P: AsRef<Path>>(
        &self,
        p: P,
        state: &mut ExecutionState
    ) -> Result<(), BndBuilderError> {
        let p = p.as_ref();
        state.task_count += 1;
        println!(
            "[{}/{}] Handle {}",
            state.task_count,
            state.nb_deps,
            p.display()
        );

        if let Some(&rule_idx) = self.node2tracked.get(p) {
            let rule = &self.tracked.rules[rule_idx];

            if !rule.is_enabled() {
                return Err(BndBuilderError::DisabledTarget(p.display().to_string()));
            }

            let done = rule.is_up_to_date();
            if done {
                println!("\t{} is already up to date", p.display());
            }
            else {
                for task in rule.commands() {
                    execute(task).map_err(|e| {
                        BndBuilderError::ExecuteError {
                            fname: p.display().to_string(),
                            msg: e
                        }
                    })?;
                }
            }
        }
        else {
            if !p.exists() {
                return Err(BndBuilderError::ExecuteError {
                    fname: p.display().to_string(),
                    msg: "no rule to build it".to_owned()
                });
            }
            else {
                println!("\t{} is already up to date", p.display())
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod test {
    use super::Task;
    use crate::deps::{expand_glob, Rule, Rules};

    #[test]
    fn test_deserialize_rule1() {
        let yaml = "targets: samourai.sna samourai.sym
dependencies: samourai.asm
commands:
  - basm samourai.asm --progress --snapshot -o samourai.sna -Idata --sym samourai.sym";
        let rule: Rule = serde_yaml::from_str(yaml).unwrap();

        assert_eq!(rule.targets.len(), 2);
        assert_eq!(rule.dependencies.len(), 1);
        assert_eq!(
            rule.commands[0],
            Task::new_basm(
                "samourai.asm --progress --snapshot -o samourai.sna -Idata --sym samourai.sym"
            )
        );
    }

    #[test]
    fn test_deserialize_rule2() {
        let yaml = "targets: samourai.sna samourai.sym
dependencies: samourai.asm
commands: basm samourai.asm --progress --snapshot -o samourai.sna -Idata --sym samourai.sym";
        let rule: Rule = serde_yaml::from_str(yaml).unwrap();

        assert_eq!(rule.targets.len(), 2);
        assert_eq!(rule.dependencies.len(), 1);
        assert_eq!(
            rule.commands[0],
            Task::new_basm(
                "samourai.asm --progress --snapshot -o samourai.sna -Idata --sym samourai.sym"
            )
        );
    }

    #[test]
    fn test_deserialize_rules1() {
        let yaml = "- targets: samourai.sna samourai.sym
  dependencies: samourai.asm
  commands:
   - basm samourai.asm --progress --snapshot -o samourai.sna -Idata --sym samourai.sym
- targets: samourai.sna samourai.sym
  dependencies: samourai.asm
  commands:
    - basm samourai.asm --progress --snapshot -o samourai.sna -Idata --sym samourai.sym";
        let rules: Rules = serde_yaml::from_str(yaml).unwrap();

        assert_eq!(rules.rules.len(), 2);
    }

    #[test]
    fn test_glob_path() {
        let fname = "samourai.{lst,sym}";
        let result = expand_glob(fname);
        eprintln!("{:?}", result);
        assert_eq!(result.len(), 2);

        let fname = "samourai.{lst,sym";
        let result = expand_glob(fname);
        eprintln!("{:?}", result);
        assert_eq!(result.len(), 1);
    }
}
