/// Represents all task target groups for a single dependency layer.
#[derive(Debug, Clone)]
pub struct TaskTargetsForLayer<'a> {
    pub tasks: Vec<TaskTargets<'a>>
}

impl<'a> TaskTargetsForLayer<'a> {
    pub fn new(tasks: Vec<TaskTargets<'a>>) -> Self {
        TaskTargetsForLayer { tasks }
    }

    pub fn iter(&self) -> std::slice::Iter<'_, TaskTargets<'a>> {
        self.tasks.iter()
    }

    pub fn tasks(&self) -> &Vec<TaskTargets<'a>> {
        &self.tasks
    }

    pub fn is_empty(&self) -> bool {
        self.tasks.is_empty()
    }

    pub fn len(&self) -> usize {
        self.tasks.len()
    }
}
/// Represents all targets generated by a single task.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TaskTargets<'a> {
    pub targets: Vec<&'a Utf8Path>
}

impl Hash for TaskTargets<'_> {
    fn hash<H: Hasher>(&self, state: &mut H) {
        // To preserve previous behavior, hash the sorted targets
        let mut targets = self.targets.clone();
        targets.sort();
        for target in targets {
            target.hash(state);
        }
    }
}

impl<'a> TaskTargets<'a> {
    pub fn new<T: Into<Vec<&'a Utf8Path>>>(targets: T) -> Self {
        TaskTargets {
            targets: targets.into()
        }
    }

    pub fn iter(&self) -> std::slice::Iter<'_, &'a Utf8Path> {
        self.targets.iter()
    }

    pub fn targets(&self) -> &Vec<&'a Utf8Path> {
        &self.targets
    }

    // the representative target is explicitely built
    pub fn representative_target(&self) -> &'a Utf8Path {
        self.targets.first().cloned().unwrap()
    }

    // the supported targets are implicitely built thanks to the representative target
    pub fn supported_targets(&self) -> impl Iterator<Item = &'a Utf8Path> {
        self.targets.iter().skip(1).cloned()
    }

    pub fn is_empty(&self) -> bool {
        self.targets.is_empty()
    }

    pub fn len(&self) -> usize {
        self.targets.len()
    }
}
/// Represents layered dependencies grouped by task, where each layer is a set of tasks, and each task is a set of targets.

#[derive(Debug, Clone)]
pub struct LayeredDependenciesByTask<'a> {
    layers: Vec<TaskTargetsForLayer<'a>>
}

impl<'a> LayeredDependenciesByTask<'a> {
    pub fn nb_layers(&self) -> usize {
        self.layers.len()
    }

    pub fn dependencies_at_layer(&self, idx: usize) -> Option<&TaskTargetsForLayer<'a>> {
        self.layers.get(idx)
    }

    pub fn iter(&self) -> std::slice::Iter<'_, TaskTargetsForLayer<'a>> {
        self.layers.iter()
    }

    pub fn targets_ordered(&self) -> impl Iterator<Item = &'a Utf8Path> {
        self.layers.iter().flat_map(|layer| {
            layer
                .tasks
                .iter()
                .flat_map(|task_targets| task_targets.targets.iter().cloned())
        })
    }

    pub fn tasks_ordered(&self) -> impl Iterator<Item = &TaskTargets<'a>> {
        self.layers.iter().flat_map(|layer| layer.tasks.iter())
    }
}

impl<'a> IntoIterator for LayeredDependenciesByTask<'a> {
    type IntoIter = std::vec::IntoIter<TaskTargetsForLayer<'a>>;
    type Item = TaskTargetsForLayer<'a>;

    fn into_iter(self) -> Self::IntoIter {
        self.layers.into_iter()
    }
}

use std::collections::BTreeMap;
use std::hash::{Hash, Hasher};

use camino::Utf8PathBuf;
use cpclib_common::camino::Utf8Path;
use cpclib_common::itertools::Itertools;
use cpclib_common::strsim;
use topologic::AcyclicDependencyGraph;

use super::{Rule, Rules};
use crate::BndBuilderError;
use crate::app::WatchState;

#[derive(Clone)]
pub struct Graph<'r> {
    pub(crate) node2tracked: BTreeMap<&'r Utf8Path, usize>,
    pub(crate) tracked: &'r Rules,
    pub(crate) g: AcyclicDependencyGraph<&'r Utf8Path>
}

impl<'r> Graph<'r> {
    pub fn get_layered_dependencies(&self) -> LayeredDependenciesByTask<'r> {
        let mut res = Vec::new();
        let layers = self.g.get_forward_dependency_topological_layers();
        for layer in layers {
            let mut task_to_targets: BTreeMap<usize, Vec<&Utf8Path>> = BTreeMap::new();
            for target in layer {
                if let Some(idx) = self.node2tracked.get(target) {
                    task_to_targets.entry(*idx).or_default().push(target);
                }
            }
            if !task_to_targets.is_empty() {
                let tasks = task_to_targets
                    .into_values()
                    .map(TaskTargets::new)
                    .collect();
                res.push(TaskTargetsForLayer::new(tasks));
            }
        }
        let orphans = self
            .tracked
            .rules()
            .iter()
            .filter(|rule| rule.dependencies().is_empty())
            .map(|r| TaskTargets::new(r.targets().iter().map(|p| p.as_path()).collect::<Vec<_>>()))
            .collect::<Vec<_>>();
        if !orphans.is_empty() {
            res.push(TaskTargetsForLayer::new(orphans));
        }
        res.reverse();
        LayeredDependenciesByTask { layers: res }
    }

    pub fn get_layered_dependencies_for<P: AsRef<Utf8Path>>(
        &self,
        p: &'r P
    ) -> LayeredDependenciesByTask<'r> {
        let p: &Utf8Path = p.as_ref();
        let layers = self.g.get_forward_dependency_topological_layers();
        let mut nodes = self.g.get_forward_dependencies(&p);
        nodes.insert(p);

        let mut res = Vec::new();
        for mut layer in layers {
            layer = layer.intersection(&nodes).cloned().collect();
            let mut task_to_targets: BTreeMap<usize, Vec<&Utf8Path>> = BTreeMap::new();
            for target in layer {
                if let Some(idx) = self.node2tracked.get(target) {
                    task_to_targets.entry(*idx).or_default().push(target);
                }
            }
            if !task_to_targets.is_empty() {
                let tasks = task_to_targets
                    .into_values()
                    .map(TaskTargets::new)
                    .collect();
                res.push(TaskTargetsForLayer::new(tasks));
            }
        }
        LayeredDependenciesByTask {
            layers: res.into_iter().filter(|l| !l.is_empty()).collect_vec()
        }
    }

    pub fn show_dependencies<P: AsRef<Utf8Path>>(&self, p: P) {
        let layers = self.get_layered_dependencies_for(&p);

        for layer in layers {
            println!("{layer:?}")
        }
    }

    pub fn outdated<P: AsRef<Utf8Path>>(
        &self,
        p: P,
        watch: &WatchState,
        skip_rules_without_commands: bool
    ) -> Result<bool, BndBuilderError> {
        let p = p.as_ref();
        // a phony rule is always outdated
        if !watch.disable_phony() && self.rule(p)?.is_phony() {
            return Ok(true);
        }

        let dependences = self.get_layered_dependencies_for(&p);
        let dependencies = dependences.targets_ordered().collect_vec();

        for p in dependencies.into_iter().rev() {
            let res = match self.rule(p) {
                Ok(r) => {
                    if skip_rules_without_commands {
                        if r.is_phony() {
                            match watch {
                                WatchState::NoWatch => false,
                                WatchState::WatchFirstRound => false,
                                WatchState::WatchNextRounds { last_build: _ } => false
                            }
                        }
                        else {
                            !r.is_up_to_date::<Utf8PathBuf>(watch.last_build().cloned(), None)
                        }
                    }
                    else {
                        !r.is_up_to_date::<Utf8PathBuf>(watch.last_build().cloned(), None)
                    }
                },

                Err(BndBuilderError::UnknownTarget(target, closests)) => {
                    if !p.exists() {
                        return Err(BndBuilderError::UnknownTarget(target, closests));
                    }
                    else if let Some(last_build) = watch.last_build() {
                        let file_modification = p.metadata().unwrap().modified().unwrap();
                        let file_modification = file_modification.elapsed().unwrap();
                        let last_build = last_build.elapsed().unwrap();
                        last_build > file_modification
                    }
                    else {
                        false
                    }
                },
                _ => todo!()
            };
            if res {
                return Ok(true);
            }
        }
        Ok(false)
        //  .unwrap_or(false) // ignore not existing rule. Should fail ?
    }

    #[inline]
    pub fn rule<P: AsRef<Utf8Path>>(&self, p: P) -> Result<&Rule, BndBuilderError> {
        let tgt = p.as_ref();

        let p = if tgt.starts_with(r"./") {
            tgt.strip_prefix(r"./").unwrap()
        }
        else if tgt.as_str().starts_with(r".\") {
            Utf8Path::new(&tgt.as_str()[2..])
        }
        else {
            tgt
        };

        self.node2tracked
            .get(p)
            .map(|idx| self.tracked.rule_at(*idx))
            .ok_or_else(|| {
                let other = self
                    .node2tracked
                    .keys()
                    .map(|key| (strsim::levenshtein(p.as_str(), key.as_str()), key.as_str()))
                    .min();

                BndBuilderError::UnknownTarget(
                    p.as_str().to_owned(),
                    other.map(|v| v.1.to_string()).unwrap_or_default()
                )
            })
    }

    #[inline]
    pub fn has_rule<P: AsRef<Utf8Path>>(&self, p: P) -> bool {
        let p = p.as_ref();
        self.node2tracked.contains_key(p)
    }
}
