use std::fmt::Display;
use std::time::SystemTime;

use cpclib_common::camino::{Utf8Path, Utf8PathBuf};
use cpclib_common::itertools::Itertools;
#[cfg(feature = "rayon")]
use cpclib_common::rayon::iter::ParallelBridge;
#[cfg(feature = "rayon")]
use cpclib_common::rayon::iter::ParallelIterator;
use serde::de::Visitor;
use serde::{self, Deserialize, Deserializer};

use crate::constraints::{Constraint, Corresponds, deserialize_constraint};
use crate::expand_glob;
use crate::task::{InnerTask, Task};

fn deserialize_path_list<'de, D>(deserializer: D) -> Result<Vec<Utf8PathBuf>, D::Error>
where D: Deserializer<'de> {
    struct SequenceOrStr;

    impl SequenceOrStr {
        fn paths_form_str(&self, s: &str) -> Vec<Utf8PathBuf> {
            let r: Vec<String> = shlex::split(s).unwrap_or_default();
            let r = r.into_iter().enumerate();

            #[cfg(feature = "rayon")]
            let r = r.par_bridge();
            let r: Vec<(usize, String)> = r
                .flat_map(|(idx, s)| {
                    expand_glob(s.as_ref())
                        .into_iter()
                        .map(|s| (idx, s))
                        .collect_vec()
                })
                .map(|(idx, s)| {
                    let s = if s.starts_with(r"./") || s.starts_with(r".\") {
                        s[2..].to_owned()
                    }
                    else {
                        s
                    };
                    (idx, s)
                })
                .collect();
            let r = r.into_iter().sorted_by_key(|(idx, _)| *idx);
            r.into_iter().map(|(_, s)| Utf8PathBuf::from(s)).collect()
        }
    }
    impl<'de> Visitor<'de> for SequenceOrStr {
        type Value = Vec<Utf8PathBuf>;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("file names or list of file names")
        }

        fn visit_str<E>(self, s: &str) -> Result<Self::Value, E>
        where E: serde::de::Error {
            let r = self.paths_form_str(s);
            Ok(r)
        }

        fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>
        where A: serde::de::SeqAccess<'de> {
            let res: Vec<String> =
                Deserialize::deserialize(serde::de::value::SeqAccessDeserializer::new(seq))?;
            let res = res
                .into_iter()
                .flat_map(|s| self.paths_form_str(&s.to_owned()))
                .collect::<Vec<_>>();
            Ok(res)
        }
    }

    deserializer.deserialize_any(SequenceOrStr)
}

impl Display for Rule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let targets = self.targets().iter().map(|p| p.to_string()).join(" ");

        writeln!(f, "\n- tgt: {targets}")?;

        if !self.dependencies.is_empty() {
            let dependencies = self.dependencies().iter().map(|p| p.to_string()).join(" ");
            writeln!(f, "  dep: {dependencies}")?;
        }

        if let Some(phony) = &self.phony {
            writeln!(f, "  phony: {phony}")?;
        }

        if let Some(help) = &self.help {
            writeln!(f, "  help: {help}")?;
        }

        if let Some(constraint) = &self.constraint {
            writeln!(f, "  constraint: {constraint}")?;
        }

        if self.commands.len() == 1 {
            writeln!(f, "  cmd: {}", &self.commands[0])?;
        }
        else if !self.commands.is_empty() {
            writeln!(f, "  cmd:")?;
            for cmd in self.commands() {
                writeln!(f, "       - {cmd}")?;
            }
        }

        Ok(())
    }
}

#[derive(Debug, Deserialize, PartialEq, Eq, Hash)]
struct DeserializedRule {
    /// List of files generated by this rule
    #[serde(deserialize_with = "deserialize_path_list")]
    #[serde(alias = "tgt", alias = "target", alias = "build")]
    targets: Vec<Utf8PathBuf>,

    /// List of dependencies that need to be up to date
    #[serde(deserialize_with = "deserialize_path_list")]
    #[serde(alias = "dep", alias = "dependency", alias = "requires")]
    #[serde(default)]
    dependencies: Vec<Utf8PathBuf>,

    /// List of commands needed to execute the rule. Can be empty if we just want to manipulate virtual targets
    #[serde(deserialize_with = "deserialize_task_list")]
    #[serde(alias = "cmd", alias = "command", alias = "launch", alias = "run")]
    #[serde(default)]
    commands: Vec<Task>,

    /// Potential help for the user
    help: Option<String>,

    /// Explicit for extern commands
    phony: Option<bool>,

    /// Constraint to disable the rule
    #[serde(deserialize_with = "deserialize_constraint")]
    #[serde(default)]
    constraint: Option<Constraint>
}

#[derive(Debug, PartialEq, Eq, Hash)]
pub struct Rule {
    /// List of files generated by this rule
    targets: Vec<Utf8PathBuf>,

    /// List of dependencies that need to be up to date
    dependencies: Vec<Utf8PathBuf>,

    /// List of commands needed to execute the rule. Can be empty if we just want to manipulate virtual targets
    commands: Vec<Task>,

    /// Potential help for the user
    help: Option<String>,

    /// Explicit for extern commands
    phony: Option<bool>,

    /// Constraint to disable the rule
    constraint: Option<Constraint>
}

impl From<DeserializedRule> for Rule {
    fn from(value: DeserializedRule) -> Self {
        Rule {
            targets: value.targets,
            dependencies: value.dependencies,
            commands: value.commands,
            help: value.help,
            phony: value.phony,
            constraint: value.constraint
        }
    }
}

impl<'de> Deserialize<'de> for Rule {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where D: Deserializer<'de> {
        let d: DeserializedRule = DeserializedRule::deserialize(deserializer)?;
        let mut r: Rule = d.into();
        r.replace_automatic_variables()
            .expect("Failed to replace automatic variables"); // Handle properly by returing error
        Ok(r)
    }
}

impl Rule {
    fn replace_automatic_variables(&mut self) -> Result<(), String> {
        let first_dep = self.dependencies.first().cloned();
        let first_dep = first_dep.as_ref().map(|p| p.as_path());
        let first_tgt = self.targets.first().cloned();
        let first_tgt = first_tgt.as_ref().map(|p| p.as_path());

        use cpclib_common::itertools::Itertools;
        use either::Either;

        let (_, errs): ((), Vec<_>) = self
            .commands
            .iter_mut()
            .map(|t| t.replace_automatic_variables(first_dep, first_tgt))
            .partition_map(|res| {
                match res {
                    Ok(val) => Either::Left(val),
                    Err(e) => Either::Right(e)
                }
            });

        if !errs.is_empty() {
            return Err(errs.join(" "));
        }
        Ok(())
    }
}

fn deserialize_task_list<'de, D>(deserializer: D) -> Result<Vec<Task>, D::Error>
where D: Deserializer<'de> {
    struct SequenceOrList;

    impl<'de> Visitor<'de> for SequenceOrList {
        type Value = Vec<Task>;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("command or list of commands")
        }

        fn visit_enum<A>(self, data: A) -> Result<Self::Value, A::Error>
        where A: serde::de::EnumAccess<'de> {
            let t: InnerTask =
                Deserialize::deserialize(serde::de::value::EnumAccessDeserializer::new(data))?;
            Ok(vec![t.into()])
        }

        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
        where E: serde::de::Error {
            let t: InnerTask = Deserialize::deserialize(serde::de::value::StrDeserializer::new(v))?;
            Ok(vec![t.into()])
        }

        fn visit_seq<A>(self, seq: A) -> Result<Self::Value, A::Error>
        where A: serde::de::SeqAccess<'de> {
            let tasks: Vec<InnerTask> =
                Deserialize::deserialize(serde::de::value::SeqAccessDeserializer::new(seq))?;
            Ok(tasks.into_iter().map(Task::from).collect_vec())
        }
    }

    deserializer.deserialize_any(SequenceOrList)
}

impl Rule {
    pub fn new_default<S1, S2>(targets: &[S1], dependencies: &[S2], kind: &str) -> Self
    where
        S1: AsRef<str>,
        S2: AsRef<str>
    {
        let task = match kind {
            "basm" => {
                Task::new_basm(&format!(
                    "-o {} {}",
                    targets[0].as_ref(),
                    dependencies[0].as_ref()
                ))
            },
            _ => unreachable!()
        };

        Self::new(targets, dependencies, &[task])
    }

    pub fn new<S1, S2, T>(targets: &[S1], dependencies: &[S2], commands: &[T]) -> Self
    where
        S1: AsRef<str>,
        S2: AsRef<str>,
        T: Into<Task> + Clone
    {
        Self {
            targets: targets
                .iter()
                .flat_map(|s| expand_glob(s.as_ref()))
                .map(Utf8PathBuf::from)
                .collect_vec(),
            dependencies: dependencies
                .iter()
                .flat_map(|s| expand_glob(s.as_ref()))
                .map(Utf8PathBuf::from)
                .collect_vec(),
            commands: commands.iter().map(|t| (t.clone()).into()).collect_vec(),
            help: None,
            phony: None,
            constraint: None
        }
    }

    pub fn commands(&self) -> &[Task] {
        &self.commands
    }

    pub(crate) fn commands_mut(&mut self) -> &mut Vec<Task> {
        &mut self.commands
    }

    /// Phony commands do not generate files and need to be launched each time (except in watch sessions)
    pub fn is_phony(&self) -> bool {
        if let Some(phony) = self.phony.as_ref() {
            return *phony;
        }

        if self.commands().is_empty() {
            true
        }
        else {
            self.commands().iter().all(|c| c.is_phony())
        }
    }

    pub fn is_parallelizable(&self) -> bool {
        self.commands().iter().all(|c| c.is_parallelizable())
    }

    pub fn is_up_to_date<P: AsRef<Utf8Path>>(
        &self,
        last_build: Option<SystemTime>,
        for_target: Option<P>
    ) -> bool {
        // phony rules are never up to date
        if self.is_phony() && last_build.is_none() {
            return false;
        }

        if let Some(target) = &for_target {
            // check if the expected target is up to date
            let target = target.as_ref();
            if !target.exists() {
                return false;
            }
        }
        else {
            // check if any target needs to be built
            if self.targets.iter().any(|p| !p.exists()) {
                return false;
            }
        }

        let oldest_target = self
            .targets
            .iter()
            .filter(|p| {
                if let Some(target) = &for_target {
                    let target = target.as_ref();
                    target == p.as_path()
                }
                else {
                    true
                }
            })
            .filter(|p| p.exists())
            .map(|p| p.metadata().unwrap().modified().unwrap())
            .min();

        let newest_dependencies = self
            .dependencies
            .iter()
            .filter(|p| p.exists())
            .map(|p| p.metadata().unwrap().modified().unwrap())
            .max();

        oldest_target > newest_dependencies
    }

    pub fn help(&self) -> Option<&str> {
        self.help.as_deref()
    }

    pub fn target(&self, idx: usize) -> &Utf8Path {
        &self.targets[idx]
    }

    pub fn targets(&self) -> &[Utf8PathBuf] {
        &self.targets
    }

    pub fn command(&self, idx: usize) -> &Task {
        &self.commands[idx]
    }

    pub fn dependencies(&self) -> &[Utf8PathBuf] {
        &self.dependencies
    }

    pub fn is_enabled(&self) -> bool {
        if let Some(constraint) = &self.constraint {
            constraint.corresponds()
        }
        else {
            true
        }
    }

    pub fn is_disabled(&self) -> bool {
        !self.is_enabled()
    }
}

#[cfg(test)]
mod tests {
    use camino::Utf8PathBuf;
    use serde::de::IntoDeserializer;
    use serde::de::value::StrDeserializer;
    use serde_yaml;

    use super::*;

    #[test]
    fn test_deserialize_path_list_single() {
        let input = "foo.txt";
        let deserializer = StrDeserializer::<serde::de::value::Error>::new(input);
        let result = deserialize_path_list(deserializer).unwrap();
        assert_eq!(result, vec![Utf8PathBuf::from("foo.txt")]);
    }

    #[test]
    fn test_deserialize_path_list_multiple_space() {
        let input = "foo.txt bar.txt baz.txt";
        let deserializer = StrDeserializer::<serde::de::value::Error>::new(input);
        let result = deserialize_path_list(deserializer).unwrap();
        assert_eq!(
            result,
            vec![
                Utf8PathBuf::from("foo.txt"),
                Utf8PathBuf::from("bar.txt"),
                Utf8PathBuf::from("baz.txt")
            ]
        );
    }

    #[test]
    fn test_deserialize_path_list_quoted() {
        let input = "'foo bar.txt' baz.txt";
        let deserializer = StrDeserializer::<serde::de::value::Error>::new(input);
        let result = deserialize_path_list(deserializer).unwrap();
        assert_eq!(
            result,
            vec![
                Utf8PathBuf::from("foo bar.txt"),
                Utf8PathBuf::from("baz.txt")
            ]
        );
    }

    #[test]
    fn test_deserialize_path_list_seq() {
        use serde::de::value::SeqDeserializer;
        let input = vec!["foo.txt", "bar.txt"];
        let deserializer = SeqDeserializer::<_, serde::de::value::Error>::new(input.into_iter());
        let result = deserialize_path_list(deserializer).unwrap();
        assert_eq!(
            result,
            vec![Utf8PathBuf::from("foo.txt"), Utf8PathBuf::from("bar.txt")]
        );
    }
}
